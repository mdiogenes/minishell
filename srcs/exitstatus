Binary file ./.ms_error_handler.c.swp matches
./aaa_debug.c:    node = mini->first_token;
./backupms_expand.c:			*dst = ft_strjoin_clean(tmp, ft_itoa(mini->exitstatus), 0);
./backupms_expand.c:			*dst = ft_strjoin_clean(tmp, ft_itoa(mini->exitstatus), 0);
./chl/chl_childs_utils.c:	if (n > -1 && mini->first_token->in == TKN_PIPEIN)
./chl/chl_childs_utils.c:		close(mini->pipes[n - 1][PIPE_READ]);
./chl/chl_childs_utils.c:		close(mini->pipes[n - 1][PIPE_WRITE]);
./chl/chl_childs_utils.c:	mini->exitstatus = WEXITSTATUS(status);
./chl/chl_childs_utils.c:		mini->exitstatus = sig | 128;
./cmd/cmd_cd.c:	if (!mini->first_token->args)
./cmd/cmd_cd.c:	if (ft_strict_cmp(mini->first_token->args->token, "-") == 0)
./cmd/cmd_cd.c:	else if (ft_strict_cmp(mini->first_token->args->token, "~") == 0)
./cmd/cmd_cd.c:	else if (ft_strict_cmp(mini->first_token->args->token, ".") == 0)
./cmd/cmd_cd.c:		return (mini->path);
./cmd/cmd_cd.c:		return (mini->first_token->args->token);
./cmd/cmd_cd.c:			printf("%d $?\n", mini->exitstatus);
./cmd/cmd_cd.c:	ft_export_var("OLDPWD", mini->path, mini);
./cmd/cmd_cd.c:	ft_export_var("PWD", mini->path, mini);
./cmd/cmd_cd.c:	mini->exitstatus = SUCCESS;
./cmd/cmd_echo.c:	dir = opendir(mini->path);
./cmd/cmd_echo.c:	mini->exitstatus = 0;
./cmd/cmd_echo.c:	token = mini->first_token->args;
./cmd/cmd_echo.c:	mini->exitstatus = 0;
./cmd/cmd_env.c:	node = mini->env;
./cmd/cmd_exit.c:		return (ft_error_comands(ERR_EXIT, mini->first_token->token, MSG_MANY_ARG, mini));
./cmd/cmd_exit.c:	mini->exitstatus = 0;
./cmd/cmd_ls.c:	arg = mini->first_token->args;
./cmd/cmd_ls.c:			arg = ft_remove_node(arg, prev, &mini->first_token->args);
./cmd/cmd_ls.c:			arg = ft_remove_node(arg, prev, &mini->first_token->args);
./cmd/cmd_ls.c:	arg = mini->first_token->args;
./cmd/cmd_ls.c:			ft_remove_node(arg, prev, &mini->first_token->args);
./cmd/cmd_ls.c:	if (mini->first_token->args)
./cmd/cmd_ls.c:		dir = opendir(mini->first_token->args->token);
./cmd/cmd_ls.c:		dir = opendir(mini->path);
./cmd/cmd_ls.c:	mini->exitstatus = 0;
./cmd/cmd_pwd.c:	ft_putendl_fd(mini->path, STDOUT_FILENO);
./cmd/cmd_pwd.c:	mini->exitstatus = 0;
./cmd/cmd_unset.c:	node = mini->env;
./cmd/cmd_unset.c:		mini->env = mini->env->next;
./cmd/cmd_unset.c:		return (mini->env);
./cmd/cmd_unset.c:	node = mini->first_token->args;
./cmd/cmd_unset.c:	mini->exitstatus = 0;
./exe/exe_forks.c:	while (mini->first_token && mini->first_token->type != OPR_CLOSE_K)
./exe/exe_forks.c:	exit(mini->status);
./exe/exe_forks.c:	if (mini->first_token->meta == MTA_KEYS)
./exe/exe_forks.c:	if (execve(mini->first_token->token, argv, argenv) == -1)
./exe/exe_forks.c:		ft_error_comands(ERR_CMD, mini->first_token->token, MSG_ERR_CMD, mini);
./exe/exe_forks.c:	exit (mini->exitstatus);
./exe/exe_forks.c:	argv = ft_build_argv(mini, mini->first_token);
./exe/exe_forks.c:	argenv = ft_build_argv(mini, mini->first_token);
./exe/exe_pipes.c:	close(mini->pipes[n][PIPE_READ]);
./exe/exe_pipes.c:	close(mini->pipes[n][PIPE_WRITE]);
./exe/exe_pipes.c:	if (mini->first_token->out == TKN_PIPEOUT)
./exe/exe_pipes.c:		dup2(mini->pipes[n][PIPE_WRITE], STDOUT_FILENO);
./exe/exe_pipes.c:	if (mini->first_token->in == TKN_PIPEIN)
./exe/exe_pipes.c:		dup2(mini->pipes[n - 1][PIPE_READ], STDIN_FILENO);
./exe/exe_pipes.c:	if (mini->first_token->meta == MTA_BUILDIN)
./exe/exe_pipes.c:	if (mini->first_token->type == RDR_TO_FILE
./exe/exe_pipes.c:		|| mini->first_token->type == RDR_APP_FILE)
./exe/exe_pipes.c:	else if (mini->first_token->type == IMP_FROM_FILE)
./exe/exe_pipes.c:	else if (mini->first_token->type == IMP_HEREDOC)
./exe/exe_pipes.c:	token = mini->first_token;
./exe/exe_pipes.c:	mini->pipes = ft_build_pipes(ft_count_pipes(mini), mini);
./exe/exe_pipes.c:	token = mini->first_token;
./exe/exe_pipes.c:			pipe(mini->pipes[n]);
./exe/exe_pipes.c:		token = mini->first_token;
Binary file ./inp/.inp_input_checks.c.swp matches
./inp/inp_export.c:	node = mini->first_token;
./inp/inp_export.c:				node = ft_remove_node(node, prev, &mini->first_token);
./inp/inp_input.c:	while (mini->line[++i])
./inp/inp_input.c:		if (mini->line[i] == ' ')
./inp/inp_input.c:		if (mini->line[i] == 34 || mini->line[i] == 39)
./inp/inp_input.c:			len = ft_strlen_chars(&mini->line[i], mini->line[i]);
./inp/inp_input.c:			len = ft_strlen_to(&mini->line[i],
./inp/inp_input.c:					ft_is_reserved(mini->line[i]));
./inp/inp_input.c:		if(mini->line[i] == '(' || mini->line[i] == ')')
./inp/inp_input.c:		if (mini->line[i] == '=' && mini->line[i - 1])
./inp/inp_input.c:			ft_export_fix(&mini->line[i - 1], &len, &i);
./inp/inp_input.c:		tmp = ft_strdup_input(&mini->line[i], len, mini);
./inp/inp_input.c:		ft_inp_append(&mini->first_token, ft_inp_new(tmp, mini));
./inp/inp_input_checks.c:	while (mini->bin_paths[i])
./inp/inp_input_checks.c:		to_test = ft_strjoin_char(mini->bin_paths[i], token, '/');
./inp/inp_input_checks.c:	if (mini->line)
./inp/inp_input_checks.c:			free (mini->line);
./inp/inp_input_checks.c:		mini->line = readline("\e[32mms-42_pipe>\e[0m ");
./inp/inp_input_checks.c:		if (!mini->line)
./inp/inp_input_checks.c:		if (ft_strlen(mini->line) > 0)
./inp/inp_input_checks.c:		if (mini->line)
./inp/inp_input_checks.c:			free (mini->line);
./inp/inp_input_checks.c:		mini->line = get_next_line(STDIN_FILENO);
./inp/inp_input_checks.c:		if (!mini->line)
./inp/inp_input_checks.c:		if (ft_count_char(mini->line, quote) > 0)
./inp/inp_input_checks.c:			mini->line = ft_strnjoin_clean(rst, mini->line, ft_strlen(rst), ft_strlen(mini->line) - 1);
./inp/inp_input_checks.c:		rst = ft_strjoin_clean(rst, mini->line, 1);
./inp/inp_input_checks.c:	token = mini->first_token;
./inp/inp_input_checks.c:	token = mini->first_token;
./inp/inp_input_checks.c:	token = mini->first_token;
./inp/inp_parse.c:	if (mini->first_token == NULL)
./inp/inp_parse.c:	ft_print_tree_debug("Parse. primera carga", mini->first_token);
./inp/inp_parse.c:	ft_print_tree_debug("Parse. despues ft_workflow", mini->first_token);
./inp/inp_parse.c:	if (!ft_get_expand(mini, mini->first_token))
./inp/inp_parse.c:	ft_print_tree_debug("parse. despues expand", mini->first_token);
./inp/inp_workflow.c:	node = mini->first_token;
./inp/inp_workflow.c:	node = mini->first_token;
./inp/inp_workflow.c:				mini->first_token = node->next;
./inp/inp_workflow.c:	node = mini->first_token;
./inp/inp_workflow.c:	ft_print_tree_debug("ft_workflow despues preproceso", mini->first_token);
./inp/inp_workflow.c:	node = mini->first_token;
./inp/inp_workflow.c:	ft_print_tree_debug("ft_workflow; despues order", mini->first_token);
./inp/inp_workflow.c:	ft_print_tree_debug("ft_workflow; despues check", mini->first_token);
./inp/inp_workflow.c:	ft_print_tree_debug("ft_workflow; despues input export", mini->first_token);
./main.c:	if (mini->first_token->meta <= MTA_BUILDIN)
./main.c:	else if (mini->first_token->meta >= MTA_BUILDIN
./main.c:		&& mini->first_token->meta <= MTA_REDIR_FILE)
./main.c:	else if (mini->first_token->meta == MTA_OPERATOR)
./main.c:	else if (mini->first_token->meta == MTA_KEYS)
./main.c:	while (mini->first_token)
./main.c:		if (mini->first_token->out == TKN_PIPEOUT)
./main.c:	if (mini->first_token == NULL)
./main.c:		if (mini->line)
./main.c:			free (mini->line);
./main.c:	ft_print_tree_debug("main", mini->first_token);
./main.c:	while (mini->status == 1)
./main.c:    		mini->line = (argv[2]);
./main.c:			mini->line = readline(mini->prompt);
./main.c:			if (!mini->line)
./main.c:			if (mini->line && *mini->line)
./main.c:				add_history(mini->line);
./main.c:			mini->status = 0;
./main.c:		printf("$? %d\n", mini->exitstatus);
./ms_error_handler.c:	mini->exitstatus = 1;
./ms_error_handler.c:	mini->exitstatus = 1;
./ms_error_handler.c:	mini->exitstatus = 1;
./ms_error_handler.c:		mini->exitstatus = 1;
./ms_error_handler.c:		mini->exitstatus = 2;	
./ms_error_handler.c:		mini->exitstatus = 127;
./ms_error_handler.c:	mini->exitstatus = 1;
./ms_error_handler.c:	mini->exitstatus = 1;
./ms_expand.c:			*dst = ft_strjoin_clean(tmp, ft_itoa(mini->exitstatus), 0);
./ms_expand.c:			*dst = ft_strjoin_clean(tmp, ft_itoa(mini->exitstatus), 0);
./ms_process.c:	if (mini->first_token->type == CMD_PWD)
./ms_process.c:	else if (mini->first_token->type == CMD_CD)
./ms_process.c:	else if (mini->first_token->type == CMD_EXIT)
./ms_process.c:	else if (mini->first_token->type == CMD_ECHO)
./ms_process.c:	else if (mini->first_token->type == CMD_ENV)
./ms_process.c:	else if (mini->first_token->type == CMD_UNSET)
./ms_process.c:	else if (mini->first_token->type == CMD_EXPORT)
./ms_process.c:		ft_error_comands(ERR_CMD, mini->first_token->token, MSG_ERR_CMD, mini);
./ms_process.c:	if (mini->first_token->out != TKN_STDIN
./ms_process.c:		|| mini->first_token->type == IMP_FROM_FILE
./ms_process.c:		|| mini->first_token->type == IMP_HEREDOC)
./ms_process.c:	if (mini->first_token->type == OPR_OR && mini->exitstatus > 0)
./ms_process.c:	if (mini->first_token->type == OPR_AND && mini->exitstatus == 0)
./ms_process.c:	if (mini->first_token->next)
./ms_process.c:	argv = ft_build_argv(mini, mini->first_token);
./ms_process.c:	argenv = ft_build_argv(mini, mini->first_token);
./ms_process.c:	if (mini->first_token && mini->first_token->type == OPR_OPEN_K)
./ms_process.c:	while (mini->first_token && mini->first_token->type != OPR_CLOSE_K)
./ms_signals.c:	mini->exitstatus = 1;
./ms_struct_utils.c:	if (mini->line)
./ms_struct_utils.c:		free (mini->line);
./ms_struct_utils.c:	if (mini->path)
./ms_struct_utils.c:		free (mini->path);
./ms_struct_utils.c:	if (mini->prompt)
./ms_struct_utils.c:		free (mini->prompt);
./ms_struct_utils.c:	if (mini->first_token)
./ms_struct_utils.c:	if (mini->bin_paths)
./ms_struct_utils.c:		ft_clear_tabs(mini->bin_paths);
./ms_struct_utils.c:	if (mini->path)
./ms_struct_utils.c:		free (mini->path);
./ms_struct_utils.c:	mini->path = ft_strdup(getcwd(pwd, PATH_MAX));
./ms_struct_utils.c:	if (mini->prompt)
./ms_struct_utils.c:		free (mini->prompt);
./ms_struct_utils.c:	tmp = ft_strjoin_clean(tmp, ft_itoa(mini->exitstatus), 0);
./ms_struct_utils.c:	mini->prompt = ft_strjoin(tmp, "]\e[0m ");
./ms_struct_utils.c:	mini->bin_paths = ft_split(path->args->token, ':');
./ms_struct_utils.c:	mini->exitstatus = 0; 
./ms_struct_utils.c:	mini->status = 1;
./ms_struct_utils.c:	mini->first_token = NULL;
./ms_struct_utils.c:	mini->line = NULL;
./ms_struct_utils.c:	mini->path = NULL;
./ms_struct_utils.c:	mini->prompt = NULL;
./ms_struct_utils.c:	mini->env = NULL;
./ms_struct_utils.c:	//mini->hello = ft_sayhello;
./ms_struct_utils.c:	//mini->bin_paths = NULL;
./rdr/rdr_functions.c:	if (mini->first_token->type == RDR_TO_FILE)
./rdr/rdr_functions.c:		fd_file = open(mini->first_token->args->token,
./rdr/rdr_functions.c:		fd_file = open(mini->first_token->args->token,
./rdr/rdr_functions.c:	if (mini->first_token->type == IMP_FROM_FILE)
./rdr/rdr_functions.c:		fd_file = open(mini->first_token->args->token, O_RDONLY, S_IRWXU);
./rdr/rdr_functions.c:		fd_file = open(mini->first_token->args->token, O_RDONLY, S_IRWXU);
./rdr/rdr_heredoc.c:	lim = mini->first_token->args->token;
./utl/utl_args.c:	size = ft_size_branch(mini->first_token->args) + 1;
./utl/utl_args.c:	size = ft_size_branch(mini->env);
./utl/utl_args.c:	node = mini->env;
./utl/utl_cleaning.c:	if (!mini->first_token)
./utl/utl_cleaning.c:	node = mini->first_token;
./utl/utl_cleaning.c:	mini->first_token = node->next;
./utl/utl_cleaning.c:	if (mini->first_token)
./utl/utl_cleaning.c:		while (mini->first_token)
./utl/utl_cleaning.c:			node = mini->first_token->next;
./utl/utl_cleaning.c:			mini->first_token = node;
./utl/utl_list.c:	node = mini->first_token;
./var/var_envars.c:	node = mini->env;
./var/var_export.c:	node = mini->env;
./var/var_export.c:		ft_env_sort(&mini->env, new);
./var/var_export.c:	if (!mini->first_token->args)
./var/var_export.c:	token = mini->first_token->args;
./var/var_export.c:		ft_env_sort(&mini->env, new);
